% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hilbert.R
\name{hilbert}
\alias{hilbert}
\title{Hilbert Transform}
\usage{
hilbert(x, pad_odd = TRUE)
}
\arguments{
\item{x}{Numeric vector. The real-valued input signal. For best FFT
performance, length should be a power of 2, but any length is supported.}

\item{pad_odd}{Logical. If \code{TRUE} (default), odd-length signals are

zero-padded to even length. If \code{FALSE}, the last element is dropped
(matching original \code{tswge} behavior, not recommended).}
}
\value{
Complex vector of the same length as \code{x} (or length + 1 if \code{x} has
odd length and \code{pad_odd = TRUE}). This is the analytic signal where:
\itemize{
\item Real part: the original signal (possibly padded/truncated)
\item Imaginary part: the Hilbert transform of the signal
}
}
\description{
Computes the Hilbert transform of a real-valued signal using the FFT-based
method, returning the analytic signal.
}
\details{
The Hilbert transform is computed using the FFT-based method:
\enumerate{
\item Compute the FFT of the input signal
\item Zero out negative frequency components
\item Double the positive frequency components
\item Compute the inverse FFT
}

The result is the analytic signal \eqn{z(t) = x(t) + i \cdot H\{x(t)\}},
where \eqn{H\{x(t)\}} is the Hilbert transform.
}
\section{Derived Quantities}{

From the analytic signal, you can compute:
\itemize{
\item \strong{Instantaneous amplitude (envelope)}: \code{Mod(z)} or \code{abs(z)}
\item \strong{Instantaneous phase}: \code{Arg(z)} or \code{atan2(Im(z), Re(z))}
\item \strong{Instantaneous frequency}: \code{diff(unwrap(Arg(z))) / (2 * pi * dt)}
\item \strong{Hilbert transform only}: \code{Im(z)}
}
}

\examples{
# Simple sinusoid
t <- seq(0, 1, length.out = 256)
x <- sin(2 * pi * 5 * t)  # 5 Hz sine wave
z <- hilbert(x)

# The envelope should be approximately 1
envelope <- Mod(z)
plot(t, envelope, type = "l", ylim = c(0, 1.5))

# Amplitude-modulated signal
carrier <- sin(2 * pi * 50 * t)
modulator <- 0.5 + 0.5 * sin(2 * pi * 2 * t)  # 2 Hz modulation
am_signal <- carrier * modulator
z_am <- hilbert(am_signal)

plot(t, am_signal, type = "l", col = "gray")
lines(t, Mod(z_am), col = "red", lwd = 2)
lines(t, modulator, col = "blue", lty = 2)  # True envelope

}
\references{
Marple, S. L. (1999). Computing the discrete-time "analytic" signal via FFT.
\emph{IEEE Transactions on Signal Processing}, 47(9), 2600-2603.
}
\seealso{
\code{\link[=fft]{fft()}} for the underlying FFT computation.
}
