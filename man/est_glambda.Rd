% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/est_glambda.R
\name{est_glambda}
\alias{est_glambda}
\title{Estimate G-Lambda Parameters}
\usage{
est_glambda(
  x,
  lambda_range = c(0, 1),
  offset_range = c(0, 100),
  lambda_by = 0.1
)
}
\arguments{
\item{x}{Numeric vector. The time series to analyze.}

\item{lambda_range}{Numeric vector of length 2: \code{c(low, high)} defining
the range for lambda. Default is \code{c(0, 1)}.}

\item{offset_range}{Numeric vector of length 2: \code{c(low, high)} defining
the range for offset. Default is \code{c(0, 100)}.}

\item{lambda_by}{Numeric. Increment for lambda grid. Default is 0.1.}
}
\value{
An object of class \code{"est_glambda"} with components:
\item{lambda}{Optimal lambda value}
\item{offset}{Optimal offset value}
\item{q}{Q-statistic at optimal parameters}
\item{table}{Data frame with all lambda/offset/Q combinations}
}
\description{
Estimate optimal lambda and offset parameters for G-lambda transformation
by grid search, minimizing the ACF difference between first and second
halves of the transformed series.
}
\details{
The function finds optimal G-lambda transformation parameters by:
\enumerate{
\item For each (lambda, offset) combination on the grid:
\itemize{
\item Transform data to dual scale using \code{\link[=trans_to_dual]{trans_to_dual()}}
\item Split transformed series in half
\item Compute ACF for each half
\item Calculate Q = sum of squared ACF differences
}
\item Select parameters that minimize Q
}

A smaller Q indicates more stationary behavior in the transformed domain,
suggesting the transformation has successfully removed non-stationarity.
}
\section{Grid Search}{

Lambda is searched from \code{lambda_range[1]} to \code{lambda_range[2]} in steps
of \code{lambda_by}. Offset is searched over all integers from \code{offset_range[1]}
to \code{offset_range[2]}.
}

\examples{
# Generate non-stationary data
set.seed(123)
t <- 1:200
x <- sin(2 * pi * t / 50) * sqrt(t) + cumsum(rnorm(200, sd = 0.5))

# Estimate optimal parameters (use narrow range for speed)
fit <- est_glambda(x, lambda_range = c(0, 0.5), offset_range = c(10, 30))
print(fit)

# Use estimated parameters for transformation
dual <- trans_to_dual(x, lambda = fit$lambda, offset = fit$offset,
                      plot = FALSE)

}
\seealso{
\code{\link[=trans_to_dual]{trans_to_dual()}} for the transformation,
\code{\link[=fore_glambda]{fore_glambda()}} for forecasting with estimated parameters.
}
