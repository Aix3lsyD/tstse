% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/est_garma.R
\name{est_garma}
\alias{est_garma}
\title{Estimate GARMA Model Parameters}
\usage{
est_garma(x, u_range, lambda_range, p_max = 5L, n_back = 500L, cores = NULL)
}
\arguments{
\item{x}{Numeric vector. The time series to analyze.}

\item{u_range}{Numeric vector of length 3: \code{c(low, high, increment)} defining
the grid for the Gegenbauer frequency parameter u.}

\item{lambda_range}{Numeric vector of length 3: \code{c(low, high, increment)}
defining the grid for the Gegenbauer persistence parameter lambda.}

\item{p_max}{Integer. Maximum AR order to consider. Default is 5.}

\item{n_back}{Integer. Number of backcasted values to prepend. Default is 500.}

\item{cores}{Integer. Number of cores for parallel processing.
Default NULL uses \code{getOption("tstse.cores", 1)}.
Set to 0 to use all available cores.}
}
\value{
An object of class \code{"est_garma"} with components:
\item{u}{Estimated Gegenbauer frequency parameter}
\item{lambda}{Estimated Gegenbauer persistence parameter}
\item{phi}{Estimated AR coefficients (0 if p = 0)}
\item{p}{Selected AR order}
\item{var_a}{Estimated residual variance}
\item{aic}{GARMA AIC value at the selected parameters}
\item{table}{Data frame with all grid search results}
}
\description{
Estimate Gegenbauer ARMA (GARMA) model parameters via grid search
with AIC-based AR order selection.
}
\details{
The function estimates parameters for a single-factor GARMA model:
\deqn{(1 - 2uB + B^2)^{-\lambda} \phi(B) X_t = a_t}

The estimation algorithm:
\enumerate{
\item Backcast the series using AR(20) Yule-Walker
\item For each (u, lambda) on the grid:
\itemize{
\item Apply Gegenbauer filter to remove long-memory component
\item Fit AR(0), AR(1), ..., AR(p_max) models
\item Select AR order by AIC
\item Compute GARMA AIC with 2-parameter penalty
}
\item Return parameters at minimum GARMA AIC
}

The GARMA AIC includes a penalty for estimating both u and lambda:
\deqn{AIC_{GARMA} = AIC_{AR} + 4/n}
when lambda is non-zero.
}
\section{Computational Notes}{

Grid search can be computationally expensive. Parallel processing is
supported via the \code{cores} parameter. For fine grids, consider:
\itemize{
\item Starting with coarse grids to narrow the search region
\item Using \code{cores = 0} to use all available cores
}
}

\examples{
# Generate GARMA data
x <- gen_garma(n = 200, u = 0.8, lambda = 0.3, phi = 0.5,
               plot = FALSE, seed = 123)

# Estimate parameters (coarse grid for speed)
fit <- est_garma(x, u_range = c(0.6, 0.9, 0.1),
                 lambda_range = c(0.1, 0.4, 0.1), p_max = 3)
print(fit)

\dontrun{
# Finer grid with parallel processing
fit2 <- est_garma(x, u_range = c(0.7, 0.9, 0.05),
                  lambda_range = c(0.2, 0.4, 0.05),
                  p_max = 5, cores = 2)
}

}
\seealso{
\code{\link[=gen_garma]{gen_garma()}} for generating GARMA realizations,
\code{\link[=fore_garma]{fore_garma()}} for forecasting,
\code{\link[=gegenb]{gegenb()}} for Gegenbauer polynomial coefficients.
}
