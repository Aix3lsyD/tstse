% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/duckdb_utils.R
\name{boot_study}
\alias{boot_study}
\title{Create a Boot Study Session}
\usage{
boot_study(
  path,
  study_name,
  dgp,
  method,
  type = c("size", "power", "comparison", "custom"),
  description = NULL,
  n_planned = NULL,
  trial_name = NULL
)
}
\arguments{
\item{path}{Character. Path to the DuckDB database file.
Use ":memory:" for an in-memory database (for testing).}

\item{study_name}{Character. Name of the study.}

\item{dgp}{List. DGP parameters. Must include \code{n} (series length).
Other common parameters: \code{ar_phi}, \code{has_trend}, \code{trend_slope}.}

\item{method}{List. Method parameters. Must include \code{name} (method name)
and \code{nb} (number of bootstrap replicates). Other parameters passed
to \code{\link[=boot_db_method]{boot_db_method()}}.}

\item{type}{Character. Study type: "size", "power", "comparison", or "custom".}

\item{description}{Character. Optional study description.}

\item{n_planned}{Integer. Planned number of simulations for this trial.}

\item{trial_name}{Character. Optional name for this trial.}
}
\value{
A \code{boot_study} object (list) with methods:
\describe{
\item{\verb{$save(result)}}{Save a bootstrap result (auto-increments iteration)}
\item{\verb{$save_batch(results)}}{Save multiple results efficiently}
\item{\verb{$query(...)}}{Query runs for this trial}
\item{\verb{$query_study(...)}}{Query all runs in the study (across trials)}
\item{\verb{$complete()}}{Mark the trial as completed}
\item{\verb{$end()}}{Close the database connection}
\item{\verb{$info}}{List with path, study_name, study_id, dgp_id, method_id, trial_id}
}
}
\description{
Creates a study session that returns bound functions for saving results
and querying the database. Uses a closure/factory pattern for clean,
self-contained state management.
}
\details{
Each call to \code{boot_study()} creates a NEW TRIAL. If you want to add
results to an existing trial, use the lower-level functions directly.

The returned object uses closures to capture the database connection
and configuration IDs. This avoids global state issues and makes each
study session self-contained.

Always call \verb{$end()} when done to close the database connection.
Use \code{on.exit(study$end())} in scripts for automatic cleanup on error.
}
\examples{
\dontrun{
# Create a study session (creates a new trial)
study <- boot_study("my_study.duckdb", "AR1 Size Study",
                    dgp = list(n = 100, ar_phi = 0.7),
                    method = list(name = "wbg_boot", nb = 399),
                    type = "size",
                    n_planned = 1000,
                    trial_name = "Trial 1")
on.exit(study$end())

# Run simulations
for (sim in 1:1000) {
  x <- gen_arma(100, phi = 0.7, plot = FALSE)
  result <- wbg_boot(x, nb = 399, seed = sim * 1000)
  study$save(result)
}

# Mark trial complete and get results
study$complete()
runs <- study$query()

# Run a second trial with same config
study2 <- boot_study("my_study.duckdb", "AR1 Size Study",
                     dgp = list(n = 100, ar_phi = 0.7),
                     method = list(name = "wbg_boot", nb = 399),
                     type = "size",
                     n_planned = 1000,
                     trial_name = "Trial 2")
# ... run more simulations ...
study2$complete()
study2$end()

# Query aggregated results across all trials
con <- boot_db_connect("my_study.duckdb", read_only = TRUE)
boot_db_rejection_rates(con, "AR1 Size Study")
boot_db_rejection_rates(con, "AR1 Size Study", by_trial = TRUE)
DBI::dbDisconnect(con)
}

}
\seealso{
\code{\link[=boot_db_connect]{boot_db_connect()}}, \code{\link[=boot_db_write]{boot_db_write()}}, \code{\link[=boot_db_query]{boot_db_query()}}, \code{\link[=boot_db_trial]{boot_db_trial()}}
}
