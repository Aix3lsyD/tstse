% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen_garma.R
\name{gen_garma}
\alias{gen_garma}
\title{Generate GARMA Process Realization}
\usage{
gen_garma(
  n,
  u,
  lambda,
  phi = 0,
  theta = 0,
  n_trunc = 1000L,
  burn_in = 600L,
  var_a = 1,
  plot = TRUE,
  seed = NULL
)
}
\arguments{
\item{n}{Integer. Length of the realization to generate.}

\item{u}{Numeric vector. Gegenbauer frequency parameters (length 1 or 2).
Each value should be in [-1, 1], determining the spectral peak frequency
as \eqn{f = \arccos(u) / (2\pi)}. Special cases:
\itemize{
\item \code{u = 1}: Long memory at frequency 0 (like ARFIMA)
\item \code{u = 0}: Long memory at frequency 0.25
\item \code{u = -1}: Long memory at frequency 0.5 (Nyquist)
}}

\item{lambda}{Numeric vector. Gegenbauer persistence parameters (same length
as \code{u}). Values in (0, 0.5) give stationary long memory.}

\item{phi}{Numeric vector. AR coefficients (default 0 = no AR component).}

\item{theta}{Numeric vector. MA coefficients (default 0 = no MA component).
Uses negated sign convention (matches textbook notation).}

\item{n_trunc}{Integer. Truncation point for the infinite GLP approximation.
Default is 1000.}

\item{burn_in}{Integer. Burn-in period to remove transient effects.
Default is 600.}

\item{var_a}{Numeric. Variance of the white noise innovations. Default is 1.}

\item{plot}{Logical. If \code{TRUE} (default), plot the realization.}

\item{seed}{Integer or NULL. Random seed for reproducibility.}
}
\value{
Numeric vector of length \code{n} containing the GARMA realization.
Returned invisibly if \code{plot = TRUE}.
}
\description{
Generate a realization from a k-factor Generalized ARMA (GARMA) model,
which combines Gegenbauer long-memory factors with ARMA components.
}
\details{
A k-factor GARMA model has the form:
\deqn{\prod_{j=1}^{k}(1 - 2u_jB + B^2)^{-\lambda_j} \phi(B) X_t = \theta(B) a_t}

where:
\itemize{
\item \eqn{(1 - 2u_jB + B^2)^{-\lambda_j}} are Gegenbauer factors
\item \eqn{\phi(B)} is the AR polynomial
\item \eqn{\theta(B)} is the MA polynomial
\item \eqn{a_t} is white noise
}

The function generates the process using the General Linear Process (GLP)
representation. First, a Gegenbauer process is generated via \code{\link[=gen_geg]{gen_geg()}},
then filtered through the AR/MA components.
}
\section{Stationarity}{

For stationarity with a single Gegenbauer factor:
\itemize{
\item If \eqn{|u| < 1}: need \eqn{\lambda < 0.5}
\item If \eqn{u = \pm 1}: need \eqn{\lambda < 0.25}
}
}

\examples{
# Pure Gegenbauer process (no AR/MA)
x <- gen_garma(n = 200, u = 0.8, lambda = 0.4, seed = 123)

# GARMA with AR(1) component
x <- gen_garma(n = 200, u = 0.5, lambda = 0.3, phi = 0.7, seed = 123)

# GARMA with AR(2) and MA(1) components
x <- gen_garma(n = 200, u = 0.8, lambda = 0.4,
               phi = c(1.2, -0.5), theta = 0.3, seed = 123)

# Two-factor GARMA (long memory at two frequencies)
x <- gen_garma(n = 200, u = c(0.8, 0.3), lambda = c(0.3, 0.2), seed = 123)

# Without plot
x <- gen_garma(n = 100, u = 0.5, lambda = 0.3, plot = FALSE, seed = 42)

}
\references{
Ferrara, L., & Guegan, D. (2001). Forecasting with k-factor Gegenbauer
processes: Theory and applications. \emph{Journal of Forecasting}, 20(8), 581-601.
}
\seealso{
\code{\link[=gen_geg]{gen_geg()}} for pure Gegenbauer process,
\code{\link[=est_garma]{est_garma()}} for parameter estimation,
\code{\link[=fore_garma]{fore_garma()}} for forecasting,
\code{\link[=gen_arma]{gen_arma()}} for ARMA process generation.
}
