# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' AR Transform (C++ implementation)
#'
#' Applies AR transformation phi(B) to a time series.
#' W_t = x_t - phi_1 * x_{t-1} - phi_2 * x_{t-2} - ... - phi_p * x_{t-p}
#' Equivalent to: artrans(x, phi, plot = FALSE)
#'
#' @param x Numeric vector, the time series.
#' @param phi Numeric vector, AR coefficients.
#' @return Numeric vector of transformed series (length n-p).
#' @keywords internal
#' @noRd
ar_transform_cpp <- function(x, phi) {
    .Call(`_tstse_ar_transform_cpp`, x, phi)
}

#' CO Time Transform (C++ implementation)
#'
#' Transforms time index for Cochrane-Orcutt procedure.
#' t_co[t] = t - sum_{j=1}^p phi_j * (t - j)
#' for t = p+1, ..., n
#'
#' @param n Integer, series length.
#' @param phi Numeric vector, AR coefficients.
#' @return Numeric vector of transformed time indices (length n-p).
#' @keywords internal
#' @noRd
co_time_transform_cpp <- function(n, phi) {
    .Call(`_tstse_co_time_transform_cpp`, n, phi)
}

#' Backcast residuals (C++ implementation)
#'
#' @param x Numeric vector, the time series.
#' @param phi Numeric vector, AR coefficients.
#' @param theta Numeric vector, MA coefficients.
#' @param n_back Integer, how far back to backcast.
#' @return Numeric vector of residuals.
#' @keywords internal
#' @noRd
backcast_cpp <- function(x, phi, theta, n_back = 50L) {
    .Call(`_tstse_backcast_cpp`, x, phi, theta, n_back)
}

burg_aic_select_pure_export <- function(x, maxp = 5L, criterion = "aic") {
    .Call(`_tstse_burg_aic_select_pure_export`, x, maxp, criterion)
}

#' Burg AR Fit with AIC Selection (C++ implementation)
#'
#' Estimates AR coefficients using Burg algorithm and selects optimal
#' order via AIC in a single pass (fused computation).
#' Equivalent to: aic_burg(x, p = 1:maxp, type = "aic")
#'
#' @param x Numeric vector, the time series.
#' @param maxp Integer, maximum AR order to consider.
#' @param criterion String, information criterion: "aic", "aicc", or "bic".
#' @return List with:
#'   - p: selected AR order
#'   - phi: AR coefficients (length p)
#'   - vara: residual variance
#'   - aic: AIC value for selected model
#' @keywords internal
#' @noRd
burg_aic_select_cpp <- function(x, maxp, criterion = "aic") {
    .Call(`_tstse_burg_aic_select_cpp`, x, maxp, criterion)
}

#' Burg AR Fit (C++ implementation)
#'
#' Estimates AR coefficients using the Burg algorithm.
#' Equivalent to: ar.burg(x, order.max = p, aic = FALSE)$ar
#'
#' @param x Numeric vector, the centered time series.
#' @param p Integer, the AR order to fit.
#' @return Numeric vector of AR coefficients (length p).
#' @keywords internal
#' @noRd
burg_fit_cpp <- function(x, p) {
    .Call(`_tstse_burg_fit_cpp`, x, p)
}

#' Burg AR Fit with Variance (C++ implementation)
#'
#' Returns AR coefficients and residual variance.
#'
#' @param x Numeric vector, the time series (not necessarily centered).
#' @param p Integer, the AR order to fit.
#' @return List with phi (coefficients) and vara (residual variance).
#' @keywords internal
#' @noRd
burg_fit_full_cpp <- function(x, p) {
    .Call(`_tstse_burg_fit_full_cpp`, x, p)
}

#' OLS t-statistic for slope (C++ implementation)
#'
#' Computes t-statistic for slope coefficient from simple linear regression.
#'
#' @param y Numeric vector, response variable.
#' @param t_idx Numeric vector, predictor (time index).
#' @return Double, t-statistic for slope.
#' @keywords internal
#' @noRd
ols_tstat_cpp <- function(y, t_idx) {
    .Call(`_tstse_ols_tstat_cpp`, y, t_idx)
}

#' Cochrane-Orcutt t-statistic (C++ implementation)
#'
#' Computes the Cochrane-Orcutt t-statistic for testing H0: slope = 0.
#' This is a fused implementation that combines all steps in C++.
#' Equivalent to: co(x, maxp, method = "burg", type = "aic")$tco
#'
#' @param x Numeric vector, the time series.
#' @param maxp Integer, maximum AR order for model selection.
#' @param criterion String, information criterion: "aic", "aicc", or "bic".
#' @return Double, Cochrane-Orcutt t-statistic.
#' @keywords internal
#' @noRd
co_tstat_cpp <- function(x, maxp = 5L, criterion = "aic") {
    .Call(`_tstse_co_tstat_cpp`, x, maxp, criterion)
}

#' Cochrane-Orcutt Full Results (C++ implementation)
#'
#' Returns full CO results including AR order and coefficients.
#' For debugging and validation purposes.
#'
#' @param x Numeric vector, the time series.
#' @param maxp Integer, maximum AR order for model selection.
#' @param criterion String, information criterion: "aic", "aicc", or "bic".
#' @return List with tco, p, phi, and vara.
#' @keywords internal
#' @noRd
co_full_cpp <- function(x, maxp = 5L, criterion = "aic") {
    .Call(`_tstse_co_full_cpp`, x, maxp, criterion)
}

co_tstat_pure_export <- function(x, maxp = 5L, criterion = "aic") {
    .Call(`_tstse_co_tstat_pure_export`, x, maxp, criterion)
}

co_full_pure_export <- function(x, maxp = 5L, criterion = "aic") {
    .Call(`_tstse_co_full_pure_export`, x, maxp, criterion)
}

#' Truncated Polynomial Convolution (C++ implementation)
#'
#' Computes the first n coefficients of the product of two power series.
#' Used for multiplying Gegenbauer polynomial coefficient sequences.
#'
#' @param C1 NumericVector, first coefficient sequence.
#' @param C2 NumericVector, second coefficient sequence.
#' @param n Integer, number of output coefficients.
#' @return NumericVector of length n containing convolution result.
#' @keywords internal
#' @noRd
convolve_truncated_cpp <- function(C1, C2, n) {
    .Call(`_tstse_convolve_truncated_cpp`, C1, C2, n)
}

#' Gegenbauer Polynomial Coefficients (C++ implementation)
#'
#' Computes the coefficients C_k(d, u) using the recurrence relation.
#' This is the internal C++ implementation called by the R wrapper.
#'
#' @param u Numeric scalar, cosine of the Gegenbauer frequency.
#' @param d Numeric scalar, long-memory parameter.
#' @param n_coef Integer, number of coefficients to compute.
#' @return NumericVector of length n_coef containing C_0, C_1, ..., C_{n-1}.
#' @keywords internal
#' @noRd
gegenb_cpp <- function(u, d, n_coef) {
    .Call(`_tstse_gegenb_cpp`, u, d, n_coef)
}

#' Calculate Adaptive Burn-in for AR Process
#'
#' @param phi Numeric vector, AR coefficients.
#' @param n Integer, target series length.
#' @return Integer, recommended burn-in length.
#' @keywords internal
#' @noRd
calc_ar_burnin_cpp <- function(phi, n) {
    .Call(`_tstse_calc_ar_burnin_cpp`, phi, n)
}

#' Fast AR Generation using Rcpp::rnorm (NOT thread-safe)
#'
#' Uses R's vectorized rnorm for maximum single-threaded performance.
#' NOT safe for parallel execution - uses R's global RNG state.
#'
#' @param n Integer, series length to generate.
#' @param phi Numeric vector, AR coefficients.
#' @param vara Double, innovation variance.
#' @return Numeric vector of length n.
#' @keywords internal
#' @noRd
gen_ar_rcpp <- function(n, phi, vara = 1.0) {
    .Call(`_tstse_gen_ar_rcpp`, n, phi, vara)
}

#' AR Generation with dqrng scalar loop (thread-safe, slower)
#'
#' Uses dqrng's xoshiro256+ with scalar generation.
#' Thread-safe but has per-element call overhead.
#'
#' @param n Integer, series length to generate.
#' @param phi Numeric vector, AR coefficients.
#' @param vara Double, innovation variance.
#' @param rng_seed Integer, seed for this specific generation.
#' @return Numeric vector of length n.
#' @keywords internal
#' @noRd
gen_ar_dqrng_scalar <- function(n, phi, vara, rng_seed) {
    .Call(`_tstse_gen_ar_dqrng_scalar`, n, phi, vara, rng_seed)
}

#' AR Generation with Armadillo randn (thread-safe)
#'
#' Uses Armadillo's randn with explicit seeding.
#' Thread-safe when each thread uses different seed.
#'
#' @param n Integer, series length to generate.
#' @param phi Numeric vector, AR coefficients.
#' @param vara Double, innovation variance.
#' @param rng_seed Integer, seed for Armadillo's RNG.
#' @return Numeric vector of length n.
#' @keywords internal
#' @noRd
gen_ar_arma <- function(n, phi, vara, rng_seed) {
    .Call(`_tstse_gen_ar_arma`, n, phi, vara, rng_seed)
}

#' AR Generation with dqrng batched Ziggurat (thread-safe, optimized)
#'
#' Uses dqrng's fast uniform generation in batches, then applies
#' Box-Muller transform for normals. Reduces function call overhead.
#'
#' @param n Integer, series length to generate.
#' @param phi Numeric vector, AR coefficients.
#' @param vara Double, innovation variance.
#' @param rng_seed Integer, seed for this specific generation.
#' @return Numeric vector of length n.
#' @keywords internal
#' @noRd
gen_ar_dqrng_boxmuller <- function(n, phi, vara, rng_seed) {
    .Call(`_tstse_gen_ar_dqrng_boxmuller`, n, phi, vara, rng_seed)
}

#' Fast AR Generation (C++ implementation) - Original API
#'
#' @param n Integer, series length to generate.
#' @param phi Numeric vector, AR coefficients.
#' @param vara Double, innovation variance.
#' @param seed Integer, random seed for reproducibility.
#' @return Numeric vector of length n.
#' @keywords internal
#' @noRd
gen_ar_cpp <- function(n, phi, vara = 1.0, seed = NULL) {
    .Call(`_tstse_gen_ar_cpp`, n, phi, vara, seed)
}

#' Fast AR Generation with External Seed (for parallel) - Original API
#'
#' Uses Box-Muller with dqrng - reproducible and thread-safe.
#' Note: Armadillo is faster but not reproducible across calls.
#'
#' @param n Integer, series length to generate.
#' @param phi Numeric vector, AR coefficients.
#' @param vara Double, innovation variance.
#' @param rng_seed Integer, seed for this specific generation.
#' @return Numeric vector of length n.
#' @keywords internal
#' @noRd
gen_ar_seeded_cpp <- function(n, phi, vara, rng_seed) {
    .Call(`_tstse_gen_ar_seeded_cpp`, n, phi, vara, rng_seed)
}

gen_arch_cpp <- function(n, alpha0, alpha, spin = 1000L, seed = NULL) {
    .Call(`_tstse_gen_arch_cpp`, n, alpha0, alpha, spin, seed)
}

gen_garch_cpp <- function(n, alpha0, alpha, beta, spin = 1000L, seed = NULL) {
    .Call(`_tstse_gen_garch_cpp`, n, alpha0, alpha, beta, spin, seed)
}

#' OLS Detrend (C++ implementation)
#'
#' Removes linear trend from a time series via OLS regression.
#' Equivalent to: resid(lm(x ~ seq_along(x)))
#'
#' @param x Numeric vector, the time series.
#' @return Numeric vector of residuals after removing linear trend.
#' @keywords internal
#' @noRd
ols_detrend_cpp <- function(x) {
    .Call(`_tstse_ols_detrend_cpp`, x)
}

#' OLS Detrend with Coefficients (C++ implementation)
#'
#' Returns both residuals and OLS coefficients for validation.
#'
#' @param x Numeric vector, the time series.
#' @return List with residuals, intercept, and slope.
#' @keywords internal
#' @noRd
ols_detrend_full_cpp <- function(x) {
    .Call(`_tstse_ols_detrend_full_cpp`, x)
}

#' @keywords internal
#' @noRd
get_omp_threads <- function() {
    .Call(`_tstse_get_omp_threads`)
}

#' @keywords internal
#' @noRd
has_openmp <- function() {
    .Call(`_tstse_has_openmp`)
}

#' @keywords internal
#' @noRd
test_parallel_seq <- function(n, phi, vara, seeds, maxp = 5L) {
    .Call(`_tstse_test_parallel_seq`, n, phi, vara, seeds, maxp)
}

#' @keywords internal
#' @noRd
test_parallel_omp_pure <- function(n, phi, vara, seeds, maxp = 5L) {
    .Call(`_tstse_test_parallel_omp_pure`, n, phi, vara, seeds, maxp)
}

#' @keywords internal
#' @noRd
test_parallel_tbb_pure <- function(n, phi, vara, seeds, maxp = 5L) {
    .Call(`_tstse_test_parallel_tbb_pure`, n, phi, vara, seeds, maxp)
}

#' @keywords internal
#' @noRd
test_parallel_tbb_rcpp <- function(n, phi, vara, seeds, maxp = 5L) {
    .Call(`_tstse_test_parallel_tbb_rcpp`, n, phi, vara, seeds, maxp)
}

#' @keywords internal
#' @noRd
test_parallel_omp <- function(n, phi, vara, seeds, maxp = 5L) {
    .Call(`_tstse_test_parallel_omp`, n, phi, vara, seeds, maxp)
}

#' @keywords internal
#' @noRd
test_parallel_tbb <- function(n, phi, vara, seeds, maxp = 5L) {
    .Call(`_tstse_test_parallel_tbb`, n, phi, vara, seeds, maxp)
}

#' Compute Sen's Slope Estimator (C++ implementation)
#'
#' Computes the median of all pairwise slopes for robust trend estimation.
#' This is an O(n^2/2) operation optimized in C++ for speed.
#'
#' @param x Numeric vector of observations
#' @return The Sen's slope estimate (median of pairwise slopes)
#'
#' @noRd
sen_slope_cpp <- function(x) {
    .Call(`_tstse_sen_slope_cpp`, x)
}

