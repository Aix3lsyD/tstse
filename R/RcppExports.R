# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' AR Transform (C++ implementation)
#'
#' Applies AR transformation phi(B) to a time series.
#' W_t = x_t - phi_1 * x_{t-1} - phi_2 * x_{t-2} - ... - phi_p * x_{t-p}
#' Equivalent to: artrans(x, phi, plot = FALSE)
#'
#' @param x Numeric vector, the time series.
#' @param phi Numeric vector, AR coefficients.
#' @return Numeric vector of transformed series (length n-p).
#' @keywords internal
#' @noRd
ar_transform_cpp <- function(x, phi) {
    .Call(`_tstse_ar_transform_cpp`, x, phi)
}

#' CO Time Transform (C++ implementation)
#'
#' Transforms time index for Cochrane-Orcutt procedure.
#' t_co[t] = t - sum_{j=1}^p phi_j * (t - j)
#' for t = p+1, ..., n
#'
#' @param n Integer, series length.
#' @param phi Numeric vector, AR coefficients.
#' @return Numeric vector of transformed time indices (length n-p).
#' @keywords internal
#' @noRd
co_time_transform_cpp <- function(n, phi) {
    .Call(`_tstse_co_time_transform_cpp`, n, phi)
}

#' Backcast residuals (C++ implementation)
#'
#' @param x Numeric vector, the time series.
#' @param phi Numeric vector, AR coefficients.
#' @param theta Numeric vector, MA coefficients.
#' @param n_back Integer, how far back to backcast.
#' @return Numeric vector of residuals.
#' @keywords internal
#' @noRd
backcast_cpp <- function(x, phi, theta, n_back = 50L) {
    .Call(`_tstse_backcast_cpp`, x, phi, theta, n_back)
}

#' Burg AR Fit with AIC Selection (C++ implementation)
#'
#' Estimates AR coefficients using Burg algorithm and selects optimal
#' order via AIC. Uses Levinson-Durbin recursion (same as R's ar.burg).
#'
#' @param x Numeric vector, the time series.
#' @param maxp Integer, maximum AR order to consider.
#' @param criterion String, information criterion: "aic", "aicc", or "bic".
#' @param min_p Integer, minimum AR order to consider. Default 0 includes AR(0).
#'   Set to 1 to exclude AR(0) and match R's aic_burg(p=1:maxp).
#' @return List with:
#'   - p: selected AR order
#'   - phi: AR coefficients (length p)
#'   - vara: residual variance
#'   - aic: AIC value for selected model
#' @keywords internal
#' @noRd
burg_aic_select_cpp <- function(x, maxp, criterion = "aic", min_p = 0L) {
    .Call(`_tstse_burg_aic_select_cpp`, x, maxp, criterion, min_p)
}

#' Burg AR Fit (C++ implementation)
#'
#' Estimates AR coefficients using the Burg algorithm.
#' Equivalent to: ar.burg(x, order.max = p, aic = FALSE)$ar
#'
#' @param x Numeric vector, the centered time series.
#' @param p Integer, the AR order to fit.
#' @return Numeric vector of AR coefficients (length p).
#' @keywords internal
#' @noRd
burg_fit_cpp <- function(x, p) {
    .Call(`_tstse_burg_fit_cpp`, x, p)
}

#' CO-TAS Trend Test (C++ implementation)
#'
#' Cochrane-Orcutt trend test with Turner's effective sample size adjustment.
#' Uses C++ for speed.
#'
#' @param x Numeric vector, the time series.
#' @param maxp Integer, maximum AR order for model selection (default 5).
#' @param type String, information criterion: "aic", "aicc", or "bic".
#' @return List with:
#'   - pvalue: P-value for trend test (adjusted for autocorrelation)
#'   - tco: t-statistic for slope
#'   - n_a: Effective sample size
#'   - phi: AR coefficients
#'   - p: AR order selected
#' @keywords internal
#' @noRd
co_tas_cpp <- function(x, maxp = 5L, type = "aic") {
    .Call(`_tstse_co_tas_cpp`, x, maxp, type)
}

#' Cochrane-Orcutt t-statistic (C++ implementation)
#'
#' Computes the Cochrane-Orcutt t-statistic for testing H0: slope = 0.
#' This is a fused implementation that combines all steps in C++.
#' Equivalent to: co(x, maxp, method = "burg", type = "aic")$tco
#'
#' @param x Numeric vector, the time series.
#' @param maxp Integer, maximum AR order for model selection.
#' @param criterion String, information criterion: "aic", "aicc", or "bic".
#' @return Double, Cochrane-Orcutt t-statistic.
#' @keywords internal
#' @noRd
co_tstat_cpp <- function(x, maxp = 5L, criterion = "aic") {
    .Call(`_tstse_co_tstat_cpp`, x, maxp, criterion)
}

#' Cochrane-Orcutt Full Results (C++ implementation)
#'
#' Returns full CO results including AR order and coefficients.
#' For debugging and validation purposes.
#'
#' @param x Numeric vector, the time series.
#' @param maxp Integer, maximum AR order for model selection.
#' @param criterion String, information criterion: "aic", "aicc", or "bic".
#' @return List with tco, p, phi, and vara.
#' @keywords internal
#' @noRd
co_full_cpp <- function(x, maxp = 5L, criterion = "aic") {
    .Call(`_tstse_co_full_cpp`, x, maxp, criterion)
}

#' OLS Detrend (C++ implementation)
#'
#' Removes linear trend from a time series via OLS regression.
#' Equivalent to: resid(lm(x ~ seq_along(x)))
#'
#' @param x Numeric vector, the time series.
#' @return Numeric vector of residuals after removing linear trend.
#' @keywords internal
#' @noRd
ols_detrend_cpp <- function(x) {
    .Call(`_tstse_ols_detrend_cpp`, x)
}

#' CO-TAS Bootstrap Kernel (C++ Implementation)
#'
#' Runs the bootstrap loop in parallel using TBB. Each iteration generates an
#' AR series under the null hypothesis (no trend) and computes the CO-TAS
#' p-value.
#'
#' @param n Integer, series length.
#' @param phi Numeric vector, AR coefficients from null model.
#' @param vara Double, innovation variance from null model.
#' @param seeds Vector of uint64 seeds, one per bootstrap iteration.
#' @param maxp Integer, maximum AR order for CO-TAS test.
#' @param type String, IC for AR selection: "aic", "aicc", "bic".
#' @param grain_size Integer, minimum iterations per thread (default 1).
#' @return Numeric vector of bootstrap p-values.
#' @keywords internal
#' @noRd
co_tas_boot_kernel_cpp <- function(n, phi, vara, seeds, maxp = 5L, type = "aic", grain_size = 1L) {
    .Call(`_tstse_co_tas_boot_kernel_cpp`, n, phi, vara, seeds, maxp, type, grain_size)
}

#' CO-TAS t-statistic Bootstrap Kernel (C++ Implementation)
#'
#' Runs the bootstrap loop in parallel using TBB. Each iteration generates an
#' AR series under the null hypothesis (no trend) and computes the CO-TAS
#' t-statistic. Used when btest=TRUE.
#'
#' @param n Integer, series length.
#' @param phi Numeric vector, AR coefficients from null model.
#' @param vara Double, innovation variance from null model.
#' @param seeds Vector of uint64 seeds, one per bootstrap iteration.
#' @param maxp Integer, maximum AR order for CO-TAS test.
#' @param type String, IC for AR selection: "aic", "aicc", "bic".
#' @param grain_size Integer, minimum iterations per thread (default 1).
#' @return Numeric vector of bootstrap t-statistics.
#' @keywords internal
#' @noRd
co_tas_boot_tstat_kernel_cpp <- function(n, phi, vara, seeds, maxp = 5L, type = "aic", grain_size = 1L) {
    .Call(`_tstse_co_tas_boot_tstat_kernel_cpp`, n, phi, vara, seeds, maxp, type, grain_size)
}

#' CO t-statistic (kernel implementation)
#'
#' Computes Cochrane-Orcutt t-statistic using the kernel implementation.
#' This function uses the exact same algorithm as the bootstrap kernel,
#' ensuring bootstrap validity when used in wbg_boot_fast().
#'
#' @param x Numeric vector, the time series.
#' @param maxp Integer, maximum AR order for model selection.
#' @param criterion String, information criterion: "aic", "aicc", or "bic".
#' @param min_p Integer, minimum AR order for residual model (0 allows AR(0),
#'   1 matches paper's CO procedure). Default 0 for backward compatibility.
#' @return Double, Cochrane-Orcutt t-statistic.
#' @keywords internal
#' @noRd
co_tstat_pure_cpp <- function(x, maxp = 5L, criterion = "aic", min_p = 0L) {
    .Call(`_tstse_co_tstat_pure_cpp`, x, maxp, criterion, min_p)
}

#' Fast AR Generation with External Seed (for parallel use)
#'
#' Uses Box-Muller with dqrng - reproducible and thread-safe.
#' This is the primary function for parallel bootstrap.
#'
#' @param n Integer, series length to generate.
#' @param phi Numeric vector, AR coefficients.
#' @param vara Double, innovation variance.
#' @param rng_seed Integer, seed for this specific generation.
#' @return Numeric vector of length n.
#' @keywords internal
#' @noRd
gen_ar_seeded_cpp <- function(n, phi, vara, rng_seed) {
    .Call(`_tstse_gen_ar_seeded_cpp`, n, phi, vara, rng_seed)
}

#' WBG Bootstrap Kernel (C++ Implementation)
#'
#' Runs the bootstrap loop in parallel using TBB with configurable grain size.
#'
#' @param n Integer, series length.
#' @param phi Numeric vector, AR coefficients from null model.
#' @param vara Double, innovation variance from null model.
#' @param seeds Vector of uint64 seeds, one per bootstrap iteration.
#' @param maxp Integer, maximum AR order for CO test.
#' @param criterion String, IC for AR selection: "aic", "aicc", "bic".
#' @param grain_size Integer, minimum iterations per thread (default 1).
#' @param min_p Integer, minimum AR order for CO residual model (default 0).
#' @return Numeric vector of bootstrap t-statistics.
#' @keywords internal
#' @noRd
wbg_bootstrap_kernel_grain_cpp <- function(n, phi, vara, seeds, maxp = 5L, criterion = "aic", grain_size = 1L, min_p = 0L) {
    .Call(`_tstse_wbg_bootstrap_kernel_grain_cpp`, n, phi, vara, seeds, maxp, criterion, grain_size, min_p)
}

#' WBG Bootstrap COBA Kernel (C++ Implementation)
#'
#' Runs the first-stage bootstrap for COBA adjustment with configurable grain size.
#'
#' @param n Integer, series length.
#' @param phi Numeric vector, AR coefficients from null model.
#' @param vara Double, innovation variance from null model.
#' @param seeds Vector of uint64 seeds, one per bootstrap iteration.
#' @param maxp Integer, maximum AR order for CO test and AR fitting.
#' @param criterion String, IC for AR selection: "aic", "aicc", "bic".
#' @param grain_size Integer, minimum iterations per thread (default 1).
#' @param min_p Integer, minimum AR order for CO residual model (default 0).
#' @return List with tstats, phi1_values, phi_matrix, orders.
#' @keywords internal
#' @noRd
wbg_bootstrap_coba_kernel_grain_cpp <- function(n, phi, vara, seeds, maxp = 5L, criterion = "aic", grain_size = 1L, min_p = 0L) {
    .Call(`_tstse_wbg_bootstrap_coba_kernel_grain_cpp`, n, phi, vara, seeds, maxp, criterion, grain_size, min_p)
}

#' Truncated Polynomial Convolution (C++ implementation)
#'
#' Computes the first n coefficients of the product of two power series.
#' Used for multiplying Gegenbauer polynomial coefficient sequences.
#'
#' @param C1 NumericVector, first coefficient sequence.
#' @param C2 NumericVector, second coefficient sequence.
#' @param n Integer, number of output coefficients.
#' @return NumericVector of length n containing convolution result.
#' @keywords internal
#' @noRd
convolve_truncated_cpp <- function(C1, C2, n) {
    .Call(`_tstse_convolve_truncated_cpp`, C1, C2, n)
}

#' Gegenbauer Polynomial Coefficients (C++ implementation)
#'
#' Computes the coefficients C_k(d, u) using the recurrence relation.
#' This is the internal C++ implementation called by the R wrapper.
#'
#' @param u Numeric scalar, cosine of the Gegenbauer frequency.
#' @param d Numeric scalar, long-memory parameter.
#' @param n_coef Integer, number of coefficients to compute.
#' @return NumericVector of length n_coef containing C_0, C_1, ..., C_{n-1}.
#' @keywords internal
#' @noRd
gegenb_cpp <- function(u, d, n_coef) {
    .Call(`_tstse_gegenb_cpp`, u, d, n_coef)
}

gen_arch_cpp <- function(n, alpha0, alpha, spin = 1000L, seed = NULL) {
    .Call(`_tstse_gen_arch_cpp`, n, alpha0, alpha, spin, seed)
}

gen_garch_cpp <- function(n, alpha0, alpha, beta, spin = 1000L, seed = NULL) {
    .Call(`_tstse_gen_garch_cpp`, n, alpha0, alpha, beta, spin, seed)
}

#' Compute Sen's Slope Estimator (C++ implementation)
#'
#' Computes the median of all pairwise slopes for robust trend estimation.
#' This is an O(n^2/2) operation optimized in C++ for speed.
#'
#' @param x Numeric vector of observations
#' @return The Sen's slope estimate (median of pairwise slopes)
#'
#' @noRd
sen_slope_cpp <- function(x) {
    .Call(`_tstse_sen_slope_cpp`, x)
}

