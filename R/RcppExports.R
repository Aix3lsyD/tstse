# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' AR Transform (C++ implementation)
#'
#' Applies AR transformation phi(B) to a time series.
#' W_t = x_t - phi_1 * x_{t-1} - phi_2 * x_{t-2} - ... - phi_p * x_{t-p}
#' Equivalent to: artrans(x, phi, plot = FALSE)
#'
#' @param x Numeric vector, the time series.
#' @param phi Numeric vector, AR coefficients.
#' @return Numeric vector of transformed series (length n-p).
#' @keywords internal
#' @noRd
ar_transform_cpp <- function(x, phi) {
    .Call(`_tstse_ar_transform_cpp`, x, phi)
}

#' CO Time Transform (C++ implementation)
#'
#' Transforms time index for Cochrane-Orcutt procedure.
#' t_co[t] = t - sum_{j=1}^p phi_j * (t - j)
#' for t = p+1, ..., n
#'
#' @param n Integer, series length.
#' @param phi Numeric vector, AR coefficients.
#' @return Numeric vector of transformed time indices (length n-p).
#' @keywords internal
#' @noRd
co_time_transform_cpp <- function(n, phi) {
    .Call(`_tstse_co_time_transform_cpp`, n, phi)
}

#' Backcast residuals (C++ implementation)
#'
#' @param x Numeric vector, the time series.
#' @param phi Numeric vector, AR coefficients.
#' @param theta Numeric vector, MA coefficients.
#' @param n_back Integer, how far back to backcast.
#' @return Numeric vector of residuals.
#' @keywords internal
#' @noRd
backcast_cpp <- function(x, phi, theta, n_back = 50L) {
    .Call(`_tstse_backcast_cpp`, x, phi, theta, n_back)
}

burg_aic_select_pure_export <- function(x, maxp = 5L, criterion = "aic") {
    .Call(`_tstse_burg_aic_select_pure_export`, x, maxp, criterion)
}

#' Burg AR Fit with AIC Selection (C++ implementation)
#'
#' Estimates AR coefficients using Burg algorithm and selects optimal
#' order via AIC. Matches R's ar.burg() with var.method=1.
#'
#' @param x Numeric vector, the time series.
#' @param maxp Integer, maximum AR order to consider.
#' @param criterion String, information criterion: "aic", "aicc", or "bic".
#' @return List with:
#'   - p: selected AR order
#'   - phi: AR coefficients (length p)
#'   - vara: residual variance
#'   - aic: AIC value for selected model
#' @keywords internal
#' @noRd
burg_aic_select_cpp <- function(x, maxp, criterion = "aic") {
    .Call(`_tstse_burg_aic_select_cpp`, x, maxp, criterion)
}

#' Burg AR Fit (C++ implementation)
#'
#' Estimates AR coefficients using the Burg algorithm.
#' Equivalent to: ar.burg(x, order.max = p, aic = FALSE)$ar
#'
#' @param x Numeric vector, the centered time series.
#' @param p Integer, the AR order to fit.
#' @return Numeric vector of AR coefficients (length p).
#' @keywords internal
#' @noRd
burg_fit_cpp <- function(x, p) {
    .Call(`_tstse_burg_fit_cpp`, x, p)
}

#' Burg AR Fit with Variance (C++ implementation)
#'
#' Returns AR coefficients and residual variance.
#'
#' @param x Numeric vector, the time series (not necessarily centered).
#' @param p Integer, the AR order to fit.
#' @return List with phi (coefficients) and vara (residual variance).
#' @keywords internal
#' @noRd
burg_fit_full_cpp <- function(x, p) {
    .Call(`_tstse_burg_fit_full_cpp`, x, p)
}

#' OLS t-statistic for slope (C++ implementation)
#'
#' Computes t-statistic for slope coefficient from simple linear regression.
#'
#' @param y Numeric vector, response variable.
#' @param t_idx Numeric vector, predictor (time index).
#' @return Double, t-statistic for slope.
#' @keywords internal
#' @noRd
ols_tstat_cpp <- function(y, t_idx) {
    .Call(`_tstse_ols_tstat_cpp`, y, t_idx)
}

#' Cochrane-Orcutt t-statistic (C++ implementation)
#'
#' Computes the Cochrane-Orcutt t-statistic for testing H0: slope = 0.
#' This is a fused implementation that combines all steps in C++.
#' Equivalent to: co(x, maxp, method = "burg", type = "aic")$tco
#'
#' @param x Numeric vector, the time series.
#' @param maxp Integer, maximum AR order for model selection.
#' @param criterion String, information criterion: "aic", "aicc", or "bic".
#' @return Double, Cochrane-Orcutt t-statistic.
#' @keywords internal
#' @noRd
co_tstat_cpp <- function(x, maxp = 5L, criterion = "aic") {
    .Call(`_tstse_co_tstat_cpp`, x, maxp, criterion)
}

#' Cochrane-Orcutt Full Results (C++ implementation)
#'
#' Returns full CO results including AR order and coefficients.
#' For debugging and validation purposes.
#'
#' @param x Numeric vector, the time series.
#' @param maxp Integer, maximum AR order for model selection.
#' @param criterion String, information criterion: "aic", "aicc", or "bic".
#' @return List with tco, p, phi, and vara.
#' @keywords internal
#' @noRd
co_full_cpp <- function(x, maxp = 5L, criterion = "aic") {
    .Call(`_tstse_co_full_cpp`, x, maxp, criterion)
}

co_tstat_pure_export <- function(x, maxp = 5L, criterion = "aic") {
    .Call(`_tstse_co_tstat_pure_export`, x, maxp, criterion)
}

co_full_pure_export <- function(x, maxp = 5L, criterion = "aic") {
    .Call(`_tstse_co_full_pure_export`, x, maxp, criterion)
}

#' Truncated Polynomial Convolution (C++ implementation)
#'
#' Computes the first n coefficients of the product of two power series.
#' Used for multiplying Gegenbauer polynomial coefficient sequences.
#'
#' @param C1 NumericVector, first coefficient sequence.
#' @param C2 NumericVector, second coefficient sequence.
#' @param n Integer, number of output coefficients.
#' @return NumericVector of length n containing convolution result.
#' @keywords internal
#' @noRd
convolve_truncated_cpp <- function(C1, C2, n) {
    .Call(`_tstse_convolve_truncated_cpp`, C1, C2, n)
}

#' Gegenbauer Polynomial Coefficients (C++ implementation)
#'
#' Computes the coefficients C_k(d, u) using the recurrence relation.
#' This is the internal C++ implementation called by the R wrapper.
#'
#' @param u Numeric scalar, cosine of the Gegenbauer frequency.
#' @param d Numeric scalar, long-memory parameter.
#' @param n_coef Integer, number of coefficients to compute.
#' @return NumericVector of length n_coef containing C_0, C_1, ..., C_{n-1}.
#' @keywords internal
#' @noRd
gegenb_cpp <- function(u, d, n_coef) {
    .Call(`_tstse_gegenb_cpp`, u, d, n_coef)
}

#' Calculate Adaptive Burn-in for AR Process
#'
#' @param phi Numeric vector, AR coefficients.
#' @param n Integer, target series length.
#' @return Integer, recommended burn-in length.
#' @keywords internal
#' @noRd
calc_ar_burnin_cpp <- function(phi, n) {
    .Call(`_tstse_calc_ar_burnin_cpp`, phi, n)
}

#' AR Generation with dqrng scalar loop (thread-safe)
#'
#' Uses dqrng's xoshiro256+ with scalar generation.
#' Thread-safe: creates local RNG instance per call.
#'
#' @param n Integer, series length to generate.
#' @param phi Numeric vector, AR coefficients.
#' @param vara Double, innovation variance.
#' @param rng_seed Integer, seed for this specific generation.
#' @return Numeric vector of length n.
#' @keywords internal
#' @noRd
gen_ar_dqrng_scalar <- function(n, phi, vara, rng_seed) {
    .Call(`_tstse_gen_ar_dqrng_scalar`, n, phi, vara, rng_seed)
}

#' AR Generation with dqrng Box-Muller (thread-safe, optimized)
#'
#' Uses dqrng's fast uniform generation with Box-Muller transform.
#' Thread-safe: creates local RNG instance per call.
#' Generates normals in pairs for efficiency.
#'
#' @param n Integer, series length to generate.
#' @param phi Numeric vector, AR coefficients.
#' @param vara Double, innovation variance.
#' @param rng_seed Integer, seed for this specific generation.
#' @return Numeric vector of length n.
#' @keywords internal
#' @noRd
gen_ar_dqrng_boxmuller <- function(n, phi, vara, rng_seed) {
    .Call(`_tstse_gen_ar_dqrng_boxmuller`, n, phi, vara, rng_seed)
}

#' Fast AR Generation with External Seed (for parallel use)
#'
#' Uses Box-Muller with dqrng - reproducible and thread-safe.
#' This is the primary function for parallel bootstrap.
#'
#' @param n Integer, series length to generate.
#' @param phi Numeric vector, AR coefficients.
#' @param vara Double, innovation variance.
#' @param rng_seed Integer, seed for this specific generation.
#' @return Numeric vector of length n.
#' @keywords internal
#' @noRd
gen_ar_seeded_cpp <- function(n, phi, vara, rng_seed) {
    .Call(`_tstse_gen_ar_seeded_cpp`, n, phi, vara, rng_seed)
}

#' Fast AR Generation (C++ implementation)
#'
#' Generates AR process using thread-safe dqrng.
#' If seed is provided, uses it for reproducibility.
#' If no seed, generates a random seed from R's RNG.
#'
#' @param n Integer, series length to generate.
#' @param phi Numeric vector, AR coefficients.
#' @param vara Double, innovation variance.
#' @param seed Integer, random seed for reproducibility (optional).
#' @return Numeric vector of length n.
#' @keywords internal
#' @noRd
gen_ar_cpp <- function(n, phi, vara = 1.0, seed = NULL) {
    .Call(`_tstse_gen_ar_cpp`, n, phi, vara, seed)
}

gen_arch_cpp <- function(n, alpha0, alpha, spin = 1000L, seed = NULL) {
    .Call(`_tstse_gen_arch_cpp`, n, alpha0, alpha, spin, seed)
}

gen_garch_cpp <- function(n, alpha0, alpha, beta, spin = 1000L, seed = NULL) {
    .Call(`_tstse_gen_garch_cpp`, n, alpha0, alpha, beta, spin, seed)
}

#' OLS Detrend (C++ implementation)
#'
#' Removes linear trend from a time series via OLS regression.
#' Equivalent to: resid(lm(x ~ seq_along(x)))
#'
#' @param x Numeric vector, the time series.
#' @return Numeric vector of residuals after removing linear trend.
#' @keywords internal
#' @noRd
ols_detrend_cpp <- function(x) {
    .Call(`_tstse_ols_detrend_cpp`, x)
}

#' OLS Detrend with Coefficients (C++ implementation)
#'
#' Returns both residuals and OLS coefficients for validation.
#'
#' @param x Numeric vector, the time series.
#' @return List with residuals, intercept, and slope.
#' @keywords internal
#' @noRd
ols_detrend_full_cpp <- function(x) {
    .Call(`_tstse_ols_detrend_full_cpp`, x)
}

#' Sequential Bootstrap Test (Baseline)
#'
#' @param n Integer, series length.
#' @param phi Numeric vector, AR coefficients.
#' @param vara Double, innovation variance.
#' @param seeds Vector of seeds for each iteration.
#' @param maxp Integer, maximum AR order.
#' @return Numeric vector of bootstrap t-statistics.
#' @keywords internal
#' @noRd
test_parallel_seq <- function(n, phi, vara, seeds, maxp = 5L) {
    .Call(`_tstse_test_parallel_seq`, n, phi, vara, seeds, maxp)
}

#' TBB Parallel Bootstrap Test (Pure C++)
#'
#' Uses RcppParallel with pure C++ internals for thread safety.
#' This is the primary parallel implementation.
#'
#' @param n Integer, series length.
#' @param phi Numeric vector, AR coefficients.
#' @param vara Double, innovation variance.
#' @param seeds Vector of seeds for each iteration.
#' @param maxp Integer, maximum AR order.
#' @return Numeric vector of bootstrap t-statistics.
#' @keywords internal
#' @noRd
test_parallel_tbb_pure <- function(n, phi, vara, seeds, maxp = 5L) {
    .Call(`_tstse_test_parallel_tbb_pure`, n, phi, vara, seeds, maxp)
}

#' TBB Parallel Bootstrap Test (Rcpp Types)
#'
#' Uses RcppParallel with Rcpp types internally.
#' For comparison with pure C++ version.
#'
#' @param n Integer, series length.
#' @param phi Numeric vector, AR coefficients.
#' @param vara Double, innovation variance.
#' @param seeds Vector of seeds for each iteration.
#' @param maxp Integer, maximum AR order.
#' @return Numeric vector of bootstrap t-statistics.
#' @keywords internal
#' @noRd
test_parallel_tbb_rcpp <- function(n, phi, vara, seeds, maxp = 5L) {
    .Call(`_tstse_test_parallel_tbb_rcpp`, n, phi, vara, seeds, maxp)
}

#' TBB Parallel Bootstrap Test (Default)
#'
#' Default parallel bootstrap using pure C++ version.
#'
#' @param n Integer, series length.
#' @param phi Numeric vector, AR coefficients.
#' @param vara Double, innovation variance.
#' @param seeds Vector of seeds for each iteration.
#' @param maxp Integer, maximum AR order.
#' @return Numeric vector of bootstrap t-statistics.
#' @keywords internal
#' @noRd
test_parallel_tbb <- function(n, phi, vara, seeds, maxp = 5L) {
    .Call(`_tstse_test_parallel_tbb`, n, phi, vara, seeds, maxp)
}

#' Compute Sen's Slope Estimator (C++ implementation)
#'
#' Computes the median of all pairwise slopes for robust trend estimation.
#' This is an O(n^2/2) operation optimized in C++ for speed.
#'
#' @param x Numeric vector of observations
#' @return The Sen's slope estimate (median of pairwise slopes)
#'
#' @noRd
sen_slope_cpp <- function(x) {
    .Call(`_tstse_sen_slope_cpp`, x)
}

#' WBG Bootstrap Kernel (C++ Implementation)
#'
#' Runs the bootstrap loop in parallel using TBB.
#' Each iteration generates an AR series under the null hypothesis
#' (no trend) and computes the Cochrane-Orcutt t-statistic.
#'
#' @param n Integer, series length.
#' @param phi Numeric vector, AR coefficients from null model.
#' @param vara Double, innovation variance from null model.
#' @param seeds Vector of uint64 seeds, one per bootstrap iteration.
#' @param maxp Integer, maximum AR order for CO test.
#' @param criterion String, IC for AR selection: "aic", "aicc", "bic".
#' @return Numeric vector of bootstrap t-statistics.
#' @keywords internal
#' @noRd
wbg_bootstrap_kernel_cpp <- function(n, phi, vara, seeds, maxp = 5L, criterion = "aic") {
    .Call(`_tstse_wbg_bootstrap_kernel_cpp`, n, phi, vara, seeds, maxp, criterion)
}

#' WBG Bootstrap Kernel with Grain Size Control
#'
#' Same as wbg_bootstrap_kernel_cpp but with explicit grain size
#' for performance tuning.
#'
#' @param n Integer, series length.
#' @param phi Numeric vector, AR coefficients from null model.
#' @param vara Double, innovation variance from null model.
#' @param seeds Vector of uint64 seeds, one per bootstrap iteration.
#' @param maxp Integer, maximum AR order for CO test.
#' @param criterion String, IC for AR selection: "aic", "aicc", "bic".
#' @param grain_size Integer, minimum iterations per thread (default 1).
#' @return Numeric vector of bootstrap t-statistics.
#' @keywords internal
#' @noRd
wbg_bootstrap_kernel_grain_cpp <- function(n, phi, vara, seeds, maxp = 5L, criterion = "aic", grain_size = 1L) {
    .Call(`_tstse_wbg_bootstrap_kernel_grain_cpp`, n, phi, vara, seeds, maxp, criterion, grain_size)
}

#' WBG Bootstrap Kernel with COBA (C++ Implementation)
#'
#' Runs the first-stage bootstrap for COBA adjustment.
#' Each iteration generates an AR series, computes the CO t-statistic,
#' AND fits an AR model to get phi coefficients for median model selection.
#'
#' @param n Integer, series length.
#' @param phi Numeric vector, AR coefficients from null model.
#' @param vara Double, innovation variance from null model.
#' @param seeds Vector of uint64 seeds, one per bootstrap iteration.
#' @param maxp Integer, maximum AR order for CO test and AR fitting.
#' @param criterion String, IC for AR selection: "aic", "aicc", "bic".
#' @return List with:
#'   - tstats: Numeric vector of bootstrap t-statistics
#'   - phi1_values: Numeric vector of phi(1) = 1 - sum(phi) for each bootstrap
#'   - phi_matrix: Matrix (nb x maxp) of AR coefficients (zero-padded)
#'   - orders: Integer vector of selected AR orders
#' @keywords internal
#' @noRd
wbg_bootstrap_coba_kernel_cpp <- function(n, phi, vara, seeds, maxp = 5L, criterion = "aic") {
    .Call(`_tstse_wbg_bootstrap_coba_kernel_cpp`, n, phi, vara, seeds, maxp, criterion)
}

#' WBG Bootstrap COBA Kernel with Grain Size Control
#'
#' Same as wbg_bootstrap_coba_kernel_cpp but with explicit grain size.
#'
#' @param n Integer, series length.
#' @param phi Numeric vector, AR coefficients from null model.
#' @param vara Double, innovation variance from null model.
#' @param seeds Vector of uint64 seeds, one per bootstrap iteration.
#' @param maxp Integer, maximum AR order for CO test and AR fitting.
#' @param criterion String, IC for AR selection: "aic", "aicc", "bic".
#' @param grain_size Integer, minimum iterations per thread (default 1).
#' @return List with tstats, phi1_values, phi_matrix, orders.
#' @keywords internal
#' @noRd
wbg_bootstrap_coba_kernel_grain_cpp <- function(n, phi, vara, seeds, maxp = 5L, criterion = "aic", grain_size = 1L) {
    .Call(`_tstse_wbg_bootstrap_coba_kernel_grain_cpp`, n, phi, vara, seeds, maxp, criterion, grain_size)
}

